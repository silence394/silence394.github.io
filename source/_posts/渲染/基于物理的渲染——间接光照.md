---
title: 基于物理的渲染——间接光照
categories: 渲染
mathjax: true
---

在前面的文章中我们已经给出了基于物理的渲染方程：
$$
L_o = \int_{\Omega }f_r(\omega_i, \omega_o)\otimes L_i(\omega_i)\cos\theta_id\omega_i
$$
并介绍了直接光照的实现。然而在自然界中，一个物体不会单独存在，光源会照射到其他的物体上，反射的光会有一部分反射到物体上。为了模拟这种环境光照的形式，我们通过环境贴图来保存周围的环境信息，从而实现间接环境光照，因此这种光照也叫基于图像的光照 （Image Based Lighting，简称IBL）。

与直接光照不同，间接光照的入射方向位于法线的半球的各个方向，所以需要对半球方向上所有的光线求辐射率的积分。
![](http://ww1.sinaimg.cn/mw690/c5c3a364ly1fytq9oz9afj209q0773yy.jpg)
这要求给定一定入射方向，能获取这个方向的辐射率，并且能在实时渲染中求解积分方程。下面我们来解决这两个问题。
<!-- more --> 
### 一、蒙特卡洛方法
在实时渲染中求解积分是不太现实的，所以计算机图形学引入了蒙特卡洛方法来获得近似解。蒙特卡洛方法主要运用了概率论和统计学的知识，我们来简单了解一下原理。
#### 概率密度函数
随机变量X用来表示随机事件，它的值用小些字母表示，如x，称为随机数。随机变量的输入集合也可以是另一种随机变量，这时我们将服从一种分布的随机变量转换为服从另一种分布的随机变量，如$Y = f(X)$。

随机变量$X$的每个值$x$都关联着每次样本抽样时这个值出现的概率，随机变量所有可能值组成的概率分布函数称为概率密度函数（probability density function，简称为$pdf$），用$p$表示。

在渲染方程中我们用到的随机变量都是连续型随机变量。随机连续变量$X$期望的期望为：
$$
E[X] = \int xp(x)dx
$$
通常我们求的是与随机变量相关的函数$Y = f(X)$，Y的期望为：
$$
E[Y] = E[f(X)] = \int f(x)p(x)dx
$$

#### 大数定律
我们对随机变量$X$重复N次抽样，形成一系列的独立同分布的随机数，然后通过对这些随机数进行平均来近似上述的期望模型，这就是估计：
$$
\overline{X} = \frac{1}{N}\sum_{i=1}^{N}x_i
$$

随着随机抽象数目N的增大，估计的方差逐渐减小。当N无限大时，随机变量的统计平均值趋近于期望的值：
$$
E[X] \approx \overline{X} = \frac{1}{N}\sum_{i=1}^{N}x_i
$$

大数定律是蒙特卡洛方法的基础，用随机抽样和统计试验求出近似解。
#### 蒙特卡洛积分
假设$f(x)$服从概率密度函数$p(x)$，对下面的积分，有：
$$
I = \int_{a}^{b}f(x)dx = \int_{a}^{b}\frac{f(x)}{p(x)}p(x)dx = E[\frac{f(x)}{p(x)}]
$$

随意上述问题转化为了求$\frac{f(x)}{p(x)}$的期望。根据大数定律，可得估计值。

$$
I =  E[\frac{f(x)}{p(x)}] \approx\frac{1}{N}\sum_{i=1}^{N}\frac{f(x_i)}{p(x_i)}
$$

在实时渲染中，PBR的积分方程主要由这种估计思想来求解。

### 二、立方体贴图
我们解决了实时渲染中求解积分的问题，接下来我们解决给定一个方向$w_i$，获取环境辐射率的问题。

我们可以将辐射率保存到环境贴图中，通过给定的方向，可以很方便地采样出环境的辐射率：
``` glsl
vec3 radiance = textureCube(cubemap, w_i).rgb;
```

在渲染中美术制作的环境贴图通常是HDR球形贴图，常见的有[RGBE格式](https://en.wikipedia.org/wiki/RGBE_image_format)。我们需要将HDR贴图转换为CubeMap，然后对CubeMap计算积分。

#### 将SphereMap转换为CubeMap
立方体贴图的面展开如下：
![](http://ww1.sinaimg.cn/mw690/c5c3a364ly1fyto5k4g3jj20b208u0t4.jpg)
将立方体的各个面作为RenderTarget，把SphereMap的内容画到立方体的各个面中，就可以完成从SphereMap到CubeMap的转换。

从原点看向立方体的各个面，并设置相机以保证各个面采集的顺序是按照上图的方式排布的（上图中的X面和Z面的是以Y轴为摄像机的上方向采集的，采集Y面需要以X轴或Z轴为上方向采集，我在代码里选取的是Z轴）。代码如下：
``` c++
Matrix4 cubeviews[] = 
{
	Matrix4::CreateLookAtLH( Vector3::cOrigin, Vector3( 1.0f, 0.0f, 0.0f ), Vector3( 0.0f, 1.0f, 0.0f ) ), // x+
	Matrix4::CreateLookAtLH( Vector3::cOrigin, Vector3( -1.0f, 0.0f, 0.0f ), Vector3( 0.0f, 1.0f, 0.0f ) ), // x-
	Matrix4::CreateLookAtLH( Vector3::cOrigin, Vector3( 0.0f, 1.0f, 0.0f ), Vector3( 0.0f, 0.0f, -1.0f ) ), // y+
	Matrix4::CreateLookAtLH( Vector3::cOrigin, Vector3( 0.0f, -1.0f, 0.0f ), Vector3( 0.0f, 0.0f, 1.0f ) ), // y-
	Matrix4::CreateLookAtLH( Vector3::cOrigin, Vector3( 0.0f, 0.0f, 1.0f ), Vector3( 0.0f, 1.0f, 0.0f ) ), // z+
	Matrix4::CreateLookAtLH( Vector3::cOrigin, Vector3( 0.0f, 0.0f, -1.0f ), Vector3( 0.0f, 1.0f, 0.0f ) ), // z-
};
```
相机设置好之后，立方体的顶点归一化便可作为立方体贴图的采样方向。对每个CubeMap的面而言，在像素着色器中，将这个采样方向转换为SphereMap的UV，采样SphereMap，变可以把CubeMap转换为SphereMap。
[Wiki](https://en.wikipedia.org/wiki/UV_mapping)给出了将3D向量转换为UV的方法：

$$
u=0.5+{\frac {\operatorname {arctan2} (d_{z},d_{x})}{2\pi }}
$$

$$
v=0.5-{\frac {\arcsin(d_{y})}{\pi }}
$$
对这样的一张球形HDR贴图：
![](http://ww1.sinaimg.cn/mw690/c5c3a364ly1fyubjuegtjj20jx09y46u.jpg)
在我使用的引擎中，上方向为$Z$轴，需要在shader中将$Y$轴和$Z$轴做了置换，转换后的CubeMap如下图：
![](http://ww1.sinaimg.cn/mw690/c5c3a364ly1fytsrnhoyvj20fl0c10wj.jpg)
GLSL代码如下。
vs:
``` glsl
attribute vec4 position;
varying vec4 opos;
uniform mat4 wvp;
void main()
{
gl_Position = wvp * vec4(position.xyz, 1.0);
opos = position;
}
```
ps:
``` glsl
varying vec4 opos;
uniform sampler2D layer0;
const float PI = 3.14159265359;
const float doublePI = 2 * PI;
vec2 SampleSphereMap(vec3 v)
{
	v = normalize(v);
	vec2 uv = vec2(atan2(v.y, v.x), acos(v.z));
	uv /= vec2(doublePI, PI);
	uv.x += 0.5;
	return uv;
}
void main()
{
vec2 uv = SampleSphereMap(opos.xyz);
vec3 color = texture2D(layer0, uv).rgb;
gl_FragColor = vec4(color, 1.0);
}
```
将SphereMap转换为SphereMap后，我们再看在直接光照中使用的PBR渲染公式：
$$
L_o = \int_{\Omega }(\frac{c_{diff}}{π}+ \frac{D(h)G(\omega_i, \omega_o,h)F(\omega_o,h)}{4(n\cdot \omega_i)(n\cdot \omega_o)})\otimes L_i(\omega_i)\cos\theta_id\omega_i
$$
现在我们已经知道了求解积分需要的蒙特卡洛方法，但是在像素着色器里求解是不切实际的。所以我们会把这个积分预处理，将结果保存到贴图中。渲染方程分为两个部分：diffuse和specular，接下来对它们分别进行计算。

### 三、Diffuse部分
Diffuse部分的渲染方程：
$$
L_o = \frac{c_{diff}}{π}\int_{\Omega }L_i(\omega_i)\cos\theta_id\omega_i
$$
其中$L_i$是环境贴图的采样，$\theta_i$是入射光线与法线的夹角。

将这个积分方程的计算结果保存到一张辐射率图中，由于$L_o$是在法线半球上的积分，所以在求环境光照的时候，用某个点的法线采样这个辐射率贴图得到的结果就是diffuse渲染方程的积分结果。
``` glsl
vec3 envdiffuse = textureCube(radianceMap, N).rgb;
```
下面我们来解这个积分方程。

立体角的微分$d\omega = sin\theta d\theta d\varphi$，带入到渲染方程：
$$
L_o = \frac{c_{diff}}{π}\int_{\phi = 0}^{\phi = 2\pi}\int_{\theta = 0}^{\frac{\pi}{2}}L_i(\phi_i, \theta_i)\cos\theta_i \sin\theta_i 
$$
根据蒙特卡洛方法，将$\phi$和$\theta$离散化，分别分成$n1$和$n2$个采样。
$$
L_o= 
        \frac{c}{\pi} \frac{2\pi}{n_1} \frac{\frac{\pi}{2}}{n_2}  \sum_{\phi = 0}^{n1} \sum_{\theta = 0}^{n2} L_i(\phi_i, \theta_i) \cos\theta \sin\theta  d\phi d\theta = 
		\frac{c\pi}{n_1n_2} \sum_{\phi = 0}^{n1} \sum_{\theta = 0}^{n2} L_i(\phi_i, \theta_i) \cos\theta \sin\theta  d\phi d\theta
$$
同转换SphereMap一样，利用立方体的顶点当做法线，计算CubeMap在法线半球上的积分。结果如下图：
![](http://ww1.sinaimg.cn/mw690/c5c3a364ly1fytss7i0q2j20fi0btmx8.jpg)
GLSL代码如下：
```glsl
varying vec4 opos;
uniform samplerCube layer0;
const float PI = 3.14159265359;
void main()
{
vec3 N = normalize(opos.xyz);
vec3 irradiance = vec3(0.0);
vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
vec3 T = normalize(cross(up, N));
vec3 B = normalize(cross(N, T));
const float sampleDelta = 0.025;
int samplenum = 0;
for (float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta)
{
	for (float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta)
	{
		vec3 tagentnormal = vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));
		vec3 worldnormal = tagentnormal.x * T + tagentnormal.y * B + tagentnormal.z * N;
		irradiance += textureCube(layer0, worldnormal).rgb * cos(theta) * sin(theta);
		samplenum ++;
	}
}
irradiance = PI * irradiance / float(samplenum);
gl_FragColor = vec4(irradiance, 1.0);
}
```

同直接光照中一样，diffuse部分的着色要考虑金属度和菲涅尔效果。由于环境光照来自于法线半球的各个方向，不像直接光照一样有一个确定的半向量$h$来确定菲涅尔效果。还记得粗糙度roughness会影响微平面的半向量$h$吗？同样地，我们在菲涅尔公式里引入粗糙度，表面粗糙，菲涅尔效果要弱一点。下面是引入roughness的菲涅尔公式：
``` glsl
vec3 fresnelSchlickRoughness(vec3 F0, float cosa, float roughness)
{
return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosa, 5.0);
}
```
结合金属度，可以计算出环境光照的diffuse分量：
``` glsl
vec3 IBLF0 = fresnelSchlickRoughness(F0, NDotV, roughness);
vec3 ambientKS = IBLF0;
vec3 ambientKD = (vec3(1.0) - ambientKS) * vec3(1.0 - metallic);
vec3 diffuseradiance = textureCube(layer9, normal).rgb;
vec3 envdiffuse = ambientKD * diffuseradiance * albedo;
```
与直接光照的部分相加得到的效果如下，可以看到，比直接光照相比有了非常大的提升。
![](http://ww1.sinaimg.cn/mw690/c5c3a364ly1fyuvdxqqg3j212306c10t.jpg)

### 四、specular部分
specular部分的渲染方程：
$$
L_o = \int_{\Omega }\frac{D(h)G(\omega_i, \omega_o,h)F(\omega_o,h)}{4(n\cdot \omega_i)(n\cdot \omega_o)}\otimes L_i(\omega_i)\cos\theta_id\omega_i
$$

diffuse部分的法线半球的各个方向的环境光对diffuse都有贡献，而对specular而言，只有在环境光线方向在视线方向的反射方向的附近的光，才能够被人眼看到。基于微平面理论，环境光的入射光线由半向量$h$给出。

Prefilter中采用了使用重要度采样的GGX分布，由于它是一个基于微平面理论的模型，GGX分布函数与视线方向相关。在卷积的时候我们并不知道视线方向，UE4做了一个假设$N=V=R=normalize(\omega_o)$，其中$w_o$是采样prefilterMap的向量。

#### 重要度采样
When it comes to the microsurface model, we can imagine the specular lobe as the reflection orientation about the microfacet halfway vectors given some incoming light direction. Seeing as most light rays end up in a specular lobe reflected around the microfacet halfway vectors it makes sense to generate the sample vectors in a similar fashion as most would otherwise be wasted. This process is known as importance sampling.

$$
O =  \int\limits_{a}^{b} f(x) dx 
      = 
      \frac{1}{N} \sum_{i=0}^{N-1} \frac{f(x)}{pdf(x)}
$$

$$
D(h) = \dfrac{\alpha^2}{\pi ((\alpha^2-1) cos^2\theta + 1 ) ^2} 
$$
$$
\int_{\Omega} D(m) cos(\theta_m) d\omega = 1
$$
### Split Sum Approximation
蒙特卡洛积分
$$
\int\limits_H L_i(p,l) f(l, v) cos \theta_l dl \approx \frac{1}{N} \sum_{k=1}^{N} \frac{L_i(l_k) f(l_k, v) cos \theta_{l_k}}{p(l_k, v)}
$$
其中$p(l_k, v)$是概率密度函数pdf。pdf是一个在半球内积分为1的归一化函数。
$$
\frac{1}{N} \sum_{k=1}^{N} \frac{L_i(l_k) f(l_k, v) cos \theta_{l_k}}{p(l_k, v)} \approx (\frac{1}{N} \sum_{k=1}^{N} L_i(l_k) )(\frac{1}{N} \sum_{k=1}^{N} \frac{f(l_k, v) cos \theta_{l_k}}{p(l_k, v)} )
$$
### diffuse
$$
\frac{1}{N} \sum_{k=1}^{N} L_i(l_k) 
$$
PreFilter EnvionmentMap
以粗糙度为参数生成MIP。
### specular
$$
\frac{1}{N} \sum_{k=1}^{N} \frac{f(l_k, v) cos \theta_{l_k}}{p(l_k, v)} = \int\limits_H f(l, v) cos \theta_l dl
$$
$$
\int\limits_H f(l, v) cos \theta_l dl = F_0 \int\limits_H \frac {f(l, v)}{F(v,h)}(1 - (1 - v \cdot h)^5) cos \theta_l dl + \int\limits_H \frac {f(l, v)}{F(v,h)} (1 - v \cdot h)^5 cos \theta_l dl
$$

$$
\int\limits_H f(l, v) cos \theta_l dl = F_0 \cdot EnvBRDF.x + EnvBRDF.y
$$
### IBL
``` HLSL
float3 ApproximateSpecularIBL(float3 SpecularColor, float Roughness, float3 N, float3 V)
{
    float NoV = saturate(dot(N, V));
    float3 R = 2 * dot(V, N) * N - V;
    float3 PrefilteredColor = PrefilterEnvMap(Roughness, R);
    float2 EnvBRDF = IntegrateBRDF(Roughness, NoV);
    return PrefilteredColor * (SpecularColor * EnvBRDF.x + EnvBRDF.y);
}
```

### 预留
F表示累计分布函数，cdf，P([a,b])表示随机变量X落在[a, b]的概率。
$$
F\{a \leqslant  x \leqslant  b\} = \int_{a}^{b}p(x)dx
$$

### 引用
1. https://learnopengl.com/PBR/IBL/Diffuse-irradiance
2. https://learnopengl.com/PBR/IBL/Specular-IBL
3. http://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-in-practice/monte-carlo-integration
4. https://blog.csdn.net/baimafujinji/article/details/53869358
5. http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx
6. https://www.zhihu.com/search?type=content&q=%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86
7. https://zhuanlan.zhihu.com/p/33464301
8. https://schuttejoe.github.io/post/ggximportancesamplingpart1/
9. https://zhuanlan.zhihu.com/p/34944420
10. 全局光照技术——对分布px进行抽样
11. https://www.tobias-franke.eu/log/2014/03/30/notes_on_importance_sampling.html
12. https://agraphicsguy.wordpress.com/2015/11/01/sampling-microfacet-brdf/
13. http://www.reedbeta.com/blog/hows-the-ndf-really-defined/
14. https://blog.csdn.net/i_dovelemon/article/details/79248390