---
title: 基于物理的渲染——间接光照
categories: 渲染
mathjax: true
---

 渲染方程：
$$
L_o = = \int_{\Omega }f_r(\omega_i, \omega_o)\otimes L_i(\omega_i)\cos\theta_id\omega_i
$$
也叫基于图像的渲染 （Image Based Lighting，简称IBL。）
### 蒙特卡洛积分
#### 随机变量X
#### 概率密度函数
pdf,用p表示。F表示累计分布函数，cdf，P([a,b])表示随机变量X落在[a, b]的概率。
$$
F\{a \leqslant  x \leqslant  b\} = \int_{a}^{b}p(x)dx
$$
随机连续变量X期望的期望
$$
E[X] = \int xp(x)dx
$$
通常我们求的是与随机变量相关的函数$Y = f(x)$，求随机变量Y的期望
$$
E[Y] = E[f(x)] = \int f(x)p(x)dx
$$
我们不必算出Y的概率密度，只需要利用X的概率密度就可以了。
#### 大数定律
随着随机抽象数目N的增大，估计的方差逐渐减小。当N无限大时，随机变量的统计平均值趋近于期望的值。
$$
E[X] \approx \overline{X} = \frac{1}{N}\sum_{i=1}^{N}x_i
$$


#### 蒙特卡洛积分
$$
I = \int_{a}^{b}f(x)dx
$$
将被积函数沿作用域分成多个区域，计算这些面积的和的均值。
$$
I = \int_{a}^{b}f(x)dx \approx \sum_{i=1}^{N}f(x_i)\frac{(b-a)}{N}
$$

推广到一般的情况：
$$
I = \int_{a}^{b}f(x)dx = \int_{a}^{b}\frac{f(x)}{p(x)}{p(x)}dx  = E[\frac{f(x)}{p(x)}] \approx\sum_{i=1}^{N}\frac{f(x_i)}{p(x_i)}\frac{1}{N} = I_N
$$
对平均值，$p(x) = \frac{1}{b-a}$，所以

### Split Sum Approximation
蒙特卡洛积分
$$
\int\limits_H L_i(p,l) f(l, v) cos \theta_l dl \approx \frac{1}{N} \sum_{k=1}^{N} \frac{L_i(l_k) f(l_k, v) cos \theta_{l_k}}{p(l_k, v)}
$$
其中$p(l_k, v)$是概率密度函数pdf。pdf是一个在半球内积分为1的归一化函数。
$$
\frac{1}{N} \sum_{k=1}^{N} \frac{L_i(l_k) f(l_k, v) cos \theta_{l_k}}{p(l_k, v)} \approx (\frac{1}{N} \sum_{k=1}^{N} L_i(l_k) )(\frac{1}{N} \sum_{k=1}^{N} \frac{f(l_k, v) cos \theta_{l_k}}{p(l_k, v)} )
$$
### diffuse
$$
\frac{1}{N} \sum_{k=1}^{N} L_i(l_k) 
$$
PreFilter EnvionmentMap
以粗糙度为参数生成MIP。
### specular
$$
\frac{1}{N} \sum_{k=1}^{N} \frac{f(l_k, v) cos \theta_{l_k}}{p(l_k, v)} = \int\limits_H f(l, v) cos \theta_l dl
$$
$$
\int\limits_H f(l, v) cos \theta_l dl = F_0 \int\limits_H \frac {f(l, v)}{F(v,h)}(1 - (1 - v \cdot h)^5) cos \theta_l dl + \int\limits_H \frac {f(l, v)}{F(v,h)} (1 - v \cdot h)^5 cos \theta_l dl
$$

$$
\int\limits_H f(l, v) cos \theta_l dl = F_0 \cdot EnvBRDF.x + EnvBRDF.y
$$
### IBL
``` HLSL
float3 ApproximateSpecularIBL(float3 SpecularColor, float Roughness, float3 N, float3 V)
{
    float NoV = saturate(dot(N, V));
    float3 R = 2 * dot(V, N) * N - V;
    float3 PrefilteredColor = PrefilterEnvMap(Roughness, R);
    float2 EnvBRDF = IntegrateBRDF(Roughness, NoV);
    return PrefilteredColor * (SpecularColor * EnvBRDF.x + EnvBRDF.y);
}
```

### 引用
1. https://learnopengl.com/PBR/IBL/Diffuse-irradiance
2. https://learnopengl.com/PBR/IBL/Specular-IBL
3. http://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-in-practice/monte-carlo-integration
4. https://blog.csdn.net/baimafujinji/article/details/53869358
5. http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx
6. https://www.zhihu.com/search?type=content&q=%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86
