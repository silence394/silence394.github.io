---
title: 基于物理的渲染——间接光照
categories: 渲染
mathjax: true
---

在前面的文章中我们已经给出了基于物理的渲染方程：
$$
L_o = \int_{\Omega }f_r(\omega_i, \omega_o)\otimes L_i(\omega_i)\cos\theta_id\omega_i
$$
并介绍了直接光照的实现。然而在自然界中，一个物体不会单独存在，光源会照射到其他的物体上，反射的光会有一部分反射到物体上。为了模拟这种环境光照的形式，我们通过环境贴图来保存周围的环境信息，从而实现间接环境光照，因此这种光照也叫基于图像的光照 （Image Based Lighting，简称IBL）。

与直接光照不同，间接光照的入射方向位于法线的半球的各个方向，所以需要对半球方向上所有的光线求辐射率的积分。
![](http://ww1.sinaimg.cn/mw690/c5c3a364ly1fytq9oz9afj209q0773yy.jpg)
这要求给定一定入射方向，能获取这个方向的辐射率，并且能在实时渲染中求解积分方程。下面我们来解决这两个问题。
<!-- more --> 
### 一、蒙特卡洛方法
在实时渲染中求解积分是不太现实的，所以计算机图形学引入了蒙特卡洛方法来获得近似解。蒙特卡洛方法主要运用了概率论和统计学的知识，我们来简单了解一下原理。
#### 概率密度函数
随机变量X用来表示随机事件，它的值用小些字母表示，如x，称为随机数。随机变量的输入集合也可以是另一种随机变量，这时我们将服从一种分布的随机变量转换为服从另一种分布的随机变量，如$Y = f(X)$。

随机变量$X$的每个值$x$都关联着每次样本抽样时这个值出现的概率，随机变量所有可能值组成的概率分布函数称为概率密度函数（probability density function，简称为$pdf$），用$p$表示。

在渲染方程中我们用到的随机变量都是连续型随机变量。随机连续变量$X$期望的期望为：
$$
E[X] = \int xp(x)dx
$$
通常我们求的是与随机变量相关的函数$Y = f(X)$，Y的期望为：
$$
E[Y] = E[f(X)] = \int f(x)p(x)dx
$$

#### 大数定律
我们对随机变量$X$重复N次抽样，形成一系列的独立同分布的随机数，然后通过对这些随机数进行平均来近似上述的期望模型，这就是估计：
$$
\overline{X} = \frac{1}{N}\sum_{i=1}^{N}x_i
$$

随着随机抽象数目N的增大，估计的方差逐渐减小。当N无限大时，随机变量的统计平均值趋近于期望的值：
$$
E[X] \approx \overline{X} = \frac{1}{N}\sum_{i=1}^{N}x_i
$$

大数定律是蒙特卡洛方法的基础，用随机抽样和统计试验求出近似解。
#### 蒙特卡洛积分
假设$f(x)$服从概率密度函数$p(x)$，对下面的积分，有：
$$
I = \int_{a}^{b}f(x)dx = \int_{a}^{b}\frac{f(x)}{p(x)}p(x)dx = E[\frac{f(x)}{p(x)}]
$$

随意上述问题转化为了求$\frac{f(x)}{p(x)}$的期望。根据大数定律，可得估计值。

$$
I =  E[\frac{f(x)}{p(x)}] \approx\frac{1}{N}\sum_{i=1}^{N}\frac{f(x_i)}{p(x_i)}
$$

在实时渲染中，PBR的积分方程主要由这种估计思想来求解。

### 二、立方体贴图
我们解决了实时渲染中求解积分的问题，接下来我们解决给定一个方向$w_i$，获取环境辐射率的问题。

我们可以将辐射率保存到环境贴图中，通过给定的方向，可以很方便地采样出环境的辐射率：
``` glsl
vec3 radiance = textureCube(cubemap, w_i).rgb;
```

在渲染中美术制作的环境贴图通常是HDR球形贴图，常见的有[RGBE格式](https://en.wikipedia.org/wiki/RGBE_image_format)。我们需要将HDR贴图转换为CubeMap，然后对CubeMap计算积分。

#### 将SphereMap转换为CubeMap
立方体贴图的面展开如下：
![](http://ww1.sinaimg.cn/mw690/c5c3a364ly1fyto5k4g3jj20b208u0t4.jpg)
将立方体的各个面作为RenderTarget，把SphereMap的内容画到立方体的各个面中，就可以完成从SphereMap到CubeMap的转换。

从原点看向立方体的各个面，并设置相机以保证各个面采集的顺序是按照上图的方式排布的（上图中的X面和Z面的是以Y轴为摄像机的上方向采集的，采集Y面需要以X轴或Z轴为上方向采集，我在代码里选取的是Z轴）。代码如下：
``` c++
Matrix4 cubeviews[] = 
{
	Matrix4::CreateLookAtLH( Vector3::cOrigin, Vector3( 1.0f, 0.0f, 0.0f ), Vector3( 0.0f, 1.0f, 0.0f ) ), // x+
	Matrix4::CreateLookAtLH( Vector3::cOrigin, Vector3( -1.0f, 0.0f, 0.0f ), Vector3( 0.0f, 1.0f, 0.0f ) ), // x-
	Matrix4::CreateLookAtLH( Vector3::cOrigin, Vector3( 0.0f, 1.0f, 0.0f ), Vector3( 0.0f, 0.0f, -1.0f ) ), // y+
	Matrix4::CreateLookAtLH( Vector3::cOrigin, Vector3( 0.0f, -1.0f, 0.0f ), Vector3( 0.0f, 0.0f, 1.0f ) ), // y-
	Matrix4::CreateLookAtLH( Vector3::cOrigin, Vector3( 0.0f, 0.0f, 1.0f ), Vector3( 0.0f, 1.0f, 0.0f ) ), // z+
	Matrix4::CreateLookAtLH( Vector3::cOrigin, Vector3( 0.0f, 0.0f, -1.0f ), Vector3( 0.0f, 1.0f, 0.0f ) ), // z-
};
```
相机设置好之后，立方体的顶点归一化便可作为立方体贴图的采样方向。对每个CubeMap的面而言，在像素着色器中，将这个采样方向转换为SphereMap的UV，采样SphereMap，变可以把CubeMap转换为SphereMap。
[Wiki](https://en.wikipedia.org/wiki/UV_mapping)给出了将3D向量转换为UV的方法：

$$
u=0.5+{\frac {\operatorname {arctan2} (d_{z},d_{x})}{2\pi}}
$$

$$
v=0.5-{\frac {\arcsin(d_{y})}{\pi}}
$$
对这样的一张球形HDR贴图：
![](http://ww1.sinaimg.cn/mw690/c5c3a364ly1fyubjuegtjj20jx09y46u.jpg)
在我使用的引擎中，上方向为$Z$轴，需要在shader中将$Y$轴和$Z$轴做了置换，转换后的CubeMap如下图：
![](http://ww1.sinaimg.cn/mw690/c5c3a364ly1fytsrnhoyvj20fl0c10wj.jpg)
GLSL代码如下。
vs:
``` glsl
attribute vec4 position;
varying vec4 opos;
uniform mat4 wvp;
void main()
{
gl_Position = wvp * vec4(position.xyz, 1.0);
opos = position;
}
```
ps:
``` glsl
varying vec4 opos;
uniform sampler2D layer0;
const float PI = 3.14159265359;
const float doublePI = 2 * PI;
vec2 SampleSphereMap(vec3 v)
{
	v = normalize(v);
	vec2 uv = vec2(atan2(v.y, v.x), acos(v.z));
	uv /= vec2(doublePI, PI);
	uv.x += 0.5;
	return uv;
}
void main()
{
vec2 uv = SampleSphereMap(opos.xyz);
vec3 color = texture2D(layer0, uv).rgb;
gl_FragColor = vec4(color, 1.0);
}
```
将SphereMap转换为SphereMap后，我们再看在直接光照中使用的PBR渲染公式：
$$
L_o = \int_{\Omega }(\frac{c_{diff}}{π}+ \frac{D(h)G(\omega_i, \omega_o,h)F(\omega_o,h)}{4(n\cdot \omega_i)(n\cdot \omega_o)})\otimes L_i(\omega_i)\cos\theta_id\omega_i
$$
现在我们已经知道了求解积分需要的蒙特卡洛方法，但是在像素着色器里求解是不切实际的。所以我们会把这个积分预处理，将结果保存到贴图中。渲染方程分为两个部分：diffuse和specular，接下来对它们分别进行计算。

### 三、Diffuse IBL
Diffuse部分的渲染方程：
$$
L_o = \frac{c_{diff}}{π}\int_{\Omega }L_i(\omega_i)\cos\theta_id\omega_i
$$
其中$L_i$是环境贴图的采样，$\theta_i$是入射光线与法线的夹角。

将这个积分方程的计算结果保存到一张辐射率图中，由于$L_o$是在法线半球上的积分，所以在求环境光照的时候，用某个点的法线采样这个辐射率贴图得到的结果就是diffuse渲染方程的积分结果。
``` glsl
vec3 envdiffuse = textureCube(radianceMap, N).rgb;
```
下面我们来解这个积分方程。

立体角的微分$d\omega = sin\theta d\theta d\varphi$，带入到渲染方程：
$$
L_o = \frac{c_{diff}}{π}\int_{\phi = 0}^{\phi = 2\pi}\int_{\theta = 0}^{\frac{\pi}{2}}L_i(\phi_i, \theta_i)\cos\theta_i \sin\theta_i 
$$
根据蒙特卡洛方法，将$\phi$和$\theta$离散化，分别分成$n1$和$n2$个采样。
$$
L_o= 
        \frac{c}{\pi} \frac{2\pi}{n_1} \frac{\frac{\pi}{2}}{n_2}  \sum_{\phi = 0}^{n1} \sum_{\theta = 0}^{n2} L_i(\phi_i, \theta_i) \cos\theta \sin\theta  d\phi d\theta = 
		\frac{c\pi}{n_1n_2} \sum_{\phi = 0}^{n1} \sum_{\theta = 0}^{n2} L_i(\phi_i, \theta_i) \cos\theta \sin\theta  d\phi d\theta
$$
同转换SphereMap一样，利用立方体的顶点当做法线，计算CubeMap在法线半球上的积分。结果如下图：
![](http://ww1.sinaimg.cn/mw690/c5c3a364ly1fytss7i0q2j20fi0btmx8.jpg)
GLSL代码如下：
```glsl
varying vec4 opos;
uniform samplerCube layer0;
const float PI = 3.14159265359;
void main()
{
vec3 N = normalize(opos.xyz);
vec3 irradiance = vec3(0.0);
vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
vec3 T = normalize(cross(up, N));
vec3 B = normalize(cross(N, T));
const float sampleDelta = 0.025;
int samplenum = 0;
for (float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta)
{
	for (float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta)
	{
		vec3 tagentnormal = vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));
		vec3 worldnormal = tagentnormal.x * T + tagentnormal.y * B + tagentnormal.z * N;
		irradiance += textureCube(layer0, worldnormal).rgb * cos(theta) * sin(theta);
		samplenum ++;
	}
}
irradiance = PI * irradiance / float(samplenum);
gl_FragColor = vec4(irradiance, 1.0);
}
```

同直接光照中一样，diffuse部分的着色要考虑金属度和菲涅尔效果。由于环境光照来自于法线半球的各个方向，不像直接光照一样有一个确定的半向量$h$来确定菲涅尔效果。还记得粗糙度roughness会影响微平面的半向量$h$吗？同样地，我们在菲涅尔公式里引入粗糙度，表面粗糙，菲涅尔效果要弱一点。下面是引入roughness的菲涅尔公式：
``` glsl
vec3 fresnelSchlickRoughness(vec3 F0, float cosa, float roughness)
{
return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosa, 5.0);
}
```
结合金属度，可以计算出环境光照的diffuse分量：
``` glsl
vec3 IBLF0 = fresnelSchlickRoughness(F0, NDotV, roughness);
vec3 ambientKS = IBLF0;
vec3 ambientKD = (vec3(1.0) - ambientKS) * vec3(1.0 - metallic);
vec3 diffuseradiance = textureCube(layer9, normal).rgb;
vec3 envdiffuse = ambientKD * diffuseradiance * albedo;
```
与直接光照的部分相加得到的效果如下，可以看到，比直接光照相比有了非常大的提升。
![](http://ww1.sinaimg.cn/mw690/c5c3a364ly1fyuvdxqqg3j212306c10t.jpg)

### 四、Specular IBL
specular部分的渲染方程：
$$
L_o = \int_{\Omega }f_{cook-torrance}\otimes L_i(\omega_i)\cos\theta_id\omega_i
$$，其中$f_{cook-torrance}\frac{D(h)G(\omega_i, \omega_o,h)F(\omega_o,h)}{4(n\cdot \omega_i)(n\cdot \omega_o)}$。

由于diffuse的辐射率积分只与入射立体角$\omega_i$有关，可以把diffuse的常量部分移到积分外求解。但对specular而言，BDRF还依赖于出射立体角$\omega_o$。我们已经知道只有光线方向在视线方向的反射方向的附近的光，才能够被人眼看到，但是环境光来自法线半球的各个方向， 无法确定入射方向$L$，但是我们可以通过得到半向量$h$来求入射光的方向$L$。接下来掉微平面模型详细分析推导出$h$。
#### 法线分布函数
![](http://ww1.sinaimg.cn/mw690/c5c3a364ly1fyy9e5j6z6j207j03iq2v.jpg)
我们假设微平面（蓝色部分）是光滑平面（黑色部分）沿法线$n$做随机扰动后形成的不平整表面，其中红色部分是朝向半向量$h$附近的微面元集合。假设扰动前光滑平面的表面积和为$A$，扰动之后的表面积和为$A'$。定义$D(\omega_h)d\omega_h$为所有朝向$\omega_h$附近的微面元面积之和占A的比例。于是有$A\cdot D(\omega_h)d\omega_h$为朝向$\omega_h$附近的所有微面元的面积之和。可以得到：
$$
A' = \int_{\Omega} A \cdot D(\omega_h)d\omega_h
$$
$D(\omega_h)$有以下性质:
1. $D(\omega_h) \ge 0$。
2. 由于$A' = \int_{\Omega} A \cdot D(\omega_h)d\omega_h \ge A$，得 $$\int_{\Omega} D(\omega_h)d\omega_h \ge 1$。
3. 光滑表面在任意方向$\bf{v}$的投影面积，等于微平面在该方向的投影面积。于是有
$$\int_{\Omega} A \cdot D(\omega_h)(\mathbf{v}\cdot \mathbf{h}) d\omega_h = A (\mathbf{v}\cdot \mathbf{n})$$
即$\int_{\Omega} D(\omega_h)(\mathbf{v}\cdot \mathbf{h}) d\omega_h = \mathbf{v}\cdot \mathbf{n}$。特殊地取$\mathbf{v} = \mathbf{n} $，则有
$$\int_{\Omega} D(\omega_h)\cos\theta d\omega_h = 1$$
其中$\theta$是$\mathbf{h}$与$\mathbf{n}$的夹角，这就满足了法线分布函数$D(\omega_h)$的归一化条件，可以得到其概率密度函数为$p(\omega_h) = D(\omega_h)\cos\theta$。

我们知道了在立体角下的概率密度函数，将其转换为球坐标系下基于$\theta$和$\phi$的$pdf$。由于$d\omega = \sin\theta d\theta d\phi$，有
$$
p(\theta, \phi) = D(h)\cos\theta\sin\theta
$$
将我们采用的Trowbridge-Reitz GGX发现分布函数代入，得
$$
p(\theta, \phi) = \dfrac{\alpha^2cos\theta sin\theta}{\pi((\alpha^2-1) cos^2\theta+1)^2}
$$
由于$p(\theta, \phi)$式子中没有$\phi$，很容易得到$p(\theta)$：
$$
p(\theta)=\int_{0}^{2\pi}p(\theta,\phi)d\phi = \dfrac{2\alpha^2cos\theta sin\theta}{((\alpha^2-1) cos^2\theta+1)^2} 
$$
再求$p(\phi|\theta)$，有
$$
p(\phi|\theta) = \frac{p(\theta, \phi)}{p(\theta)} = \frac{1}{2\pi}
$$

对$p(\theta)$积分，得到其概率分布函数：
$$
\begin{array} {lcl} cdf_h(\theta) & = & \int_{0}^{\theta} \dfrac{2\alpha^2 cos(t) sin(t)}{(cos^2t(\alpha^2-1)+1)^2}dt \\ & = & \int_{\theta}^{0} \dfrac{\alpha^2}{(cos^2t(\alpha^2-1)+1)^2}d(cos^2t) \\ & = & \dfrac{\alpha^2}{\alpha^2-1} \int_{0}^{\theta} d{\dfrac{1}{cos^2t(\alpha^2-1)+1}}\\ & = & \dfrac{\alpha^2}{\alpha^2-1} {(\dfrac{1}{cos^2\theta(\alpha^2-1)+1}-\dfrac{1}{\alpha^2})}\\ & = & \dfrac{\alpha^2}{cos^2\theta(\alpha^2-1)^2+(\alpha^2-1)}-\dfrac{1}{\alpha^2-1} \end{array} 
$$
对$p(\phi|\theta)$求其概率分布函数：
$$
cdf_h(\phi|\theta) = \int_{0}^{\phi}p_h(\phi|\theta)dt = \frac{\phi}{2\pi}
$$

这时我们可以假设随机数 $\xi_0 = cdf_h(\theta)$，$\xi_1 = cdf_h(\phi|\theta)$，分别求得$\theta$和$\phi$。
$$
\theta =arccos\sqrt{\dfrac{1-\xi_0}{\xi_0(\alpha^2-1)+1}} 
$$
$$
\phi = 2\pi\xi_1
$$
得到$\theta$和$\phi$后，就可以得到笛卡尔坐标系下的$h$，之后便可以进行渲染方程的计算。

#### Hammersley Sequence
我们还有随机数$\xi_0$和$\xi_1$没有解决。蒙特卡洛传统的抽样方式是采用电脑的伪随机数来进行的，这种随机的特征导致每个随机数并不知道其他随机数的任何信息，所以其分布可能会出现丛聚，减慢了收敛速度。但如果使用某些方法使随机数均匀地分布，那么蒙特卡洛方法的模拟过程不会受到影响，并且收敛速度可以加快。

产生较均匀分布的随机数生成方法叫低差异序列（Low Discrepancy Sequence），而我们使用的是其中的一种——Hammersley。伪随机数和Hammersley序列生成的点集对比如下图：
![](http://ww1.sinaimg.cn/mw690/c5c3a364ly1fyxsp8mf8mj20jg0a8aj5.jpg)
有兴趣了解原理的可以阅读[这篇文章](http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html)，在这里我们直接给出Hammersley序列的生成代码。
``` glsl
float RadicalInverse_VdC(uint bits) 
{
    bits = (bits << 16u) | (bits >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    return float(bits) * 2.3283064365386963e-10; // / 0x100000000
}
// ----------------------------------------------------------------------------
vec2 Hammersley(uint i, uint N)
{
    return vec2(float(i)/float(N), RadicalInverse_VdC(i));
}  
```
到这里随机数$\xi_0$和$\xi_1$的生成也搞定了。

#### GGX重要度采样
基于蒙特卡洛积分的求解方法，我们在半球$\Omega$上生成一系列偏向半向量$h$的采样向量。与diffuse部分的求解类似，在一个循环内生成一系列低差异化的随机数，
``` glsl
const uint SAMPLE_COUNT = 1024u;
for(uint i = 0u; i < SAMPLE_COUNT; ++i)
{
	vec2 Xi = Hammersley(i, SAMPLE_COUNT);
}  
```
用这些随机数生成切线空间的向量，再将其转换到世界空间，就得到了半向量$h$。
``` glsl
vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)
{
	float a = roughness * roughness;
	float phi = 2.0 * PI * Xi.x;
	float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));
	float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
	vec3 
	H.x = cos(phi) * sinTheta;
	H.y = sin(phi) * sinTheta;
	H.z = cosTheta;
	vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
	vec3 T = normalize(cross(up, N));
	vec3 B = normalize(cross(N, T));
	vec3 normal = H.x * T + H.y * B + H.z * N;
	return normalize(normal);
}
```
至此，半向量h的求解方法已经给出。再来看specular渲染方程：
$$
L_o = \int_{\Omega }f_{cook-torrance}\otimes L_i(\omega_i)\cos\theta_id\omega_i
$$
用模特卡洛方法估计这个积分：
$$
L_o = \int_{\Omega }f_{cook-torrance}\otimes L_i(\omega_i)\cos\theta_id\omega_{ik} \approx \frac{1}{N} 
\sum_{k=1}^{N}\frac{L_i(\omega_i)f(\omega_i, \omega_o)\cos\theta_{ik}}{p(\omega_{ik}, \omega_o)}
$$
UE4用Split Sum Approximation将估计分为两个部分：
$$
\frac{1}{N} 
\sum_{k=1}^{N}\frac{L_i(\omega_{ik})f(\omega_{ik}, \omega_o)\cos\theta_{ik}}{p(\omega_{ik}, \omega_o)} \approx
\left (\frac{1}{N}\sum_{k=1}^{N}L_{ik}(\omega_{ik})  \right ) \left ( \frac{1}{N}\sum_{k=1}^{N} \frac{f(\omega_{ik}, \omega_o)\cos\theta_{ik}}{p(\omega_{ik}, \omega_o)} \right )
$$
第一部分的计算结果存储到一张叫做Pre-Filter Envionment Map的CubeMap上。
第二部分的计算结果存储到一张叫做Environment BRDF的2D贴图上。

#### Pre-Filter Envionment Map
#### Environment BRDF

### specular
$$
\frac{1}{N} \sum_{k=1}^{N} \frac{f(l_k, v) cos \theta_{l_k}}{p(l_k, v)} = \int\limits_H f(l, v) cos \theta_l dl
$$
$$
\int\limits_H f(l, v) cos \theta_l dl = F_0 \int\limits_H \frac {f(l, v)}{F(v,h)}(1 - (1 - v \cdot h)^5) cos \theta_l dl + \int\limits_H \frac {f(l, v)}{F(v,h)} (1 - v \cdot h)^5 cos \theta_l dl
$$

$$
\int\limits_H f(l, v) cos \theta_l dl = F_0 \cdot EnvBRDF.x + EnvBRDF.y
$$
### IBL
``` HLSL
float3 ApproximateSpecularIBL(float3 SpecularColor, float Roughness, float3 N, float3 V)
{
    float NoV = saturate(dot(N, V));
    float3 R = 2 * dot(V, N) * N - V;
    float3 PrefilteredColor = PrefilterEnvMap(Roughness, R);
    float2 EnvBRDF = IntegrateBRDF(Roughness, NoV);
    return PrefilteredColor * (SpecularColor * EnvBRDF.x + EnvBRDF.y);
}
```

### 预留
F表示累计分布函数，cdf，P([a,b])表示随机变量X落在[a, b]的概率。
$$
F\{a \leqslant  x \leqslant  b\} = \int_{a}^{b}p(x)dx
$$

Prefilter中采用了使用重要度采样的GGX分布，由于它是一个基于微平面理论的模型，GGX分布函数与视线方向相关。在卷积的时候我们并不知道视线方向，UE4做了一个假设$N=V=R=normalize(\omega_o)$，其中$w_o$是采样prefilterMap的向量。



### 引用
1. https://learnopengl.com/PBR/IBL/Diffuse-irradiance
2. https://learnopengl.com/PBR/IBL/Specular-IBL
3. http://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-in-practice/monte-carlo-integration
4. https://blog.csdn.net/baimafujinji/article/details/53869358
5. http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx
6. https://www.zhihu.com/search?type=content&q=%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86
7. https://zhuanlan.zhihu.com/p/33464301
8. https://schuttejoe.github.io/post/ggximportancesamplingpart1/
9. https://zhuanlan.zhihu.com/p/34944420
10. 全局光照技术——对分布px进行抽样
11. https://www.tobias-franke.eu/log/2014/03/30/notes_on_importance_sampling.html
12. https://agraphicsguy.wordpress.com/2015/11/01/sampling-microfacet-brdf/
13. http://www.reedbeta.com/blog/hows-the-ndf-really-defined/
14. https://blog.csdn.net/i_dovelemon/article/details/79248390
15. https://www.cnblogs.com/time-flow1024/p/10209093.html
16. https://zhuanlan.zhihu.com/p/20197323