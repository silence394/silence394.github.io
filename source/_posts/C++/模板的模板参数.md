---
title: 模板的模板参数
categories: C++
---

对这样一个Stack的例子，把内部容器实现为了一个模板参数：
``` C++
template <typename T, typename CONT = std::deque<T> >
class Stack
{
private:
	CONT elems;

public:
	bool empty() { return elems.empty(); }
};
```
如果要使用一个和缺省值不同的内部容器，程序员必须两次指定元素类型，即容器的类型和它包含的元素的类型：
``` C++
Stack<int, std::vector<int>> ss;
```
如果借助于模板参数，可以只指定容器的类型而不必指定所含元素的类型：
``` C++
Stack<int, std::vector> ss;
```
<!-- more --> 
为了能获得这个特性，必须把第二个模板参数指定为模板的模板参数：
``` C++
template <typename T, template <typename ELEM> class CONT = std::deque >
class Stack
{
private:
	CONT<T> elems;

public:
	bool empty() { return elems.empty(); }
};
```
第一个模板参数作为第二个模板参数的实例化类型。一般来说，可以使用类模板内部的任何类型来实例化模版的模版参数。

作为模板参数的声明，通常可以使用typename代替关键字class，但是上面的CONT是为了定义一个类，只能使用关键字class。

这个时候编译的话会得到错误信息：
> error C3201: 类模板“std::deque”的模板参数列表与模板参数“CONT”的模板参数列表不匹配

这是因为：模板的**模板实参**（如std::deque）是一个具有参数A的模板，它将替换模板的模板参数（如CONT），而模板的**模板参数**是一个具有参数B的模板；而匹配过程中要求参数A和参数B必须完全匹配。但是我们在上面没有考虑模板的**模板实参**的缺省模板参数，从而使B中缺少了这些缺省的参数值，也就不能获得精确的匹配。

对于std::deque模板还具有第二个参数，即内存分配器allocator，它有一个缺省值，但在匹配std::deque的参数和CONT的参数时，并没有考虑这个缺省值。

把allocator类型的参数加上：
``` C++
template <typename T, template <typename ELEM, typename ALLOC = std::allocator<ELEM> > class CONT = std::deque >
class Stack
{
private:
	CONT<T> elems;
    ...
};
```
那么CONT的参数就是具有两个模板参数的容器。