---
title: 模板的模板参数
categories: C++
---

对这样一个Stack的例子，把内部容器实现为了一个模板参数：
``` C++
template <typename T, typename CONT = std::deque<T> >
class Stack
{
private:
	CONT elems;

public:
	bool empty() { return elems.empty(); }
};
```
如果要使用一个和缺省值不同的内部容器，程序员必须两次指定元素类型，即容器的类型和它包含的元素的类型：
``` C++
Stack<int, std::vector<int>> ss;
```
如果借助于模板参数，可以只指定容器的类型而不必指定所含元素的类型：
``` C++
Stack<int, std::vector> ss;
```
为了能获得这个特性，必须把第二个模板参数指定为模板的模板参数：
``` C++
template <typename T, template <typename ELEM> class CONT = std::deque >
class Stack
{
private:
	CONT<T> elems;

public:
	bool empty() { return elems.empty(); }
};
```
第一个模板参数作为第二个模板参数的实例化类型。一般来说，可以使用类模板内部的任何类型来实例化模版的模版参数。

作为模板参数的声明，通常可以使用typename代替关键字class，但是上面的CONT是为了定义一个类，只能使用关键字class。


