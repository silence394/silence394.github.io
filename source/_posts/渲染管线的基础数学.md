---
title: 渲染管线的基础数学
categories: 渲染
mathjax: true
---
此篇文章总结一下3D渲染用到的基础数学变换，对渲染管线有一个更清晰的认识。假设读者已经对渲染管线有了一个大致的认知，不会花太多篇幅将渲染关系各个阶段的作用。
### 渲染管线
渲染管线是经过一系列的数学变换，将3D空间中的点，变换到屏幕空间，并进行着色的过程。
包含的流程如下：
![](http://ww1.sinaimg.cn/large/c5c3a364ly1fvgdkh0yf0j20l806rq2v.jpg)
如下图，顶点经过从世界空间变换到投影空间，投影空间下的顶点经过透视除法转换为标准设备空间坐标，再变换到视口下的坐标，将顶点组织成图元，光栅化着色并显示。
![image](https://i.loli.net/2018/09/13/5b9a7ab5a36b9.png)
![IMAGE](https://i.loli.net/2018/09/13/5b9a7ceaa9510.png)

这一系列变换实际上是对点和向量的数学运算，在3D渲染中采用了矩阵用于点和向量的变换。

### 矩阵
#### 矩阵的引入
先介绍一下为什么矩阵可以表示变换。在这边文章中我们以行向量进行矩阵的排布，矩阵的每一行都能解释为变换后的基向量，后面的矩阵全部在左手坐标系，并且基于行向量。

考虑一个向量**V**
$$
V = \begin{bmatrix}
x & y & z 
\end{bmatrix}
= \begin{bmatrix}
x & 0 & 0 
\end{bmatrix}
+
\begin{bmatrix}
0 & y & 0 
\end{bmatrix}
+
\begin{bmatrix}
0 & 0 & z 
\end{bmatrix}
= x\begin{bmatrix}
1 & 0 & 0 
\end{bmatrix}
+
y\begin{bmatrix}
0 & 1 & 0 
\end{bmatrix}
+
z\begin{bmatrix}
0 & 0 & 1 
\end{bmatrix}
$$
也就是向量**V**可以表示为+x, +y, +z轴的单位向量的变换组合。

假设**p**,**q**,**r**分别对应+x,+y,+z轴的单位向量，那么向量**V**就可以表示成**p**,**q**,**r**的线性变换，**p**,**q**,**r**即为基向量。
$$
V = x\mathbf{p} + y\mathbf{q} + z\mathbf{r}
= \begin{bmatrix}
x & y & z 
\end{bmatrix}
\begin{bmatrix}
\mathbf{p} \\ 
\mathbf{q}\\ 
\mathbf{z}
\end{bmatrix}
= \begin{bmatrix}
x & y & z 
\end{bmatrix}
\begin{bmatrix}
p_x & p_y & p_z\\ 
q_x & q_y & q_z\\ 
r_x & r_y & r_z
\end{bmatrix}
$$
那么我们可以定义矩阵**M**，将向量(x, y , z)变换到**V**，即**M**为从(x, y, z)到**V**的变换矩阵。
$$
\boldsymbol{M} = \begin{bmatrix}
p_x & p_y & p_z\\ 
q_x & q_y & q_z\\ 
r_x & r_y & r_z
\end{bmatrix}
$$
如果感觉比较难以理解，这个视频[Transmations](https://www.youtube.com/watch?v=kYB8IZa5AuE&feature=youtu.be&list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab&t=193)或OpenGL的[变换](https://learnopengl-cn.github.io/01%20Getting%20started/07%20Transformations/)可以让你对矩阵表示线性变换有个直观的感受。
#### 旋转和缩放矩阵
考虑一个矩阵2x2的矩阵**M**
$$
M = \begin{bmatrix}
1 & 1\\ 
-1 & 1 \\ 
\end{bmatrix}
$$
从这个矩阵中抽取变换后的基向量**p** = [1 1], **q** = [-1 1]，假设原基向量是(1, 0), (-1, 0)，那么矩阵M表示了对向量缩放$\sqrt{1^2 + 1^2} = \sqrt{1^2 + -1^2} = \sqrt{2}$，然后逆时针旋转$45^{\circ}$。

想要缩放某个向量，只需要将向量的各个分量，分别乘以各个轴的缩放因子。如向量**p**(x, y, z)分别乘以各个轴的缩放$s_x$, $s_y$, $s_z$，得$p\mathbf{'}$，

$$
p' =\begin{bmatrix}
 p_x * s_x & p_y * s_y  &  p_z * s_z
\end{bmatrix}
= p
\begin{bmatrix}
s_x & 0 & 0 \\ 
0 & s_y & 0 \\ 
0 & 0 & s_z
\end{bmatrix}
$$

所以缩放矩阵为:
$$
M = \begin{bmatrix}
s_x & 0 & 0 \\ 
0 & s_y & 0 \\ 
0 & 0 & s_z
\end{bmatrix}
$$

接下来看旋转矩阵，先在2D坐标系里看向量的旋转。在XOY坐标系内任意一点**v**(x, y),其与x轴的夹角为α度，将其旋转β度，得到**v'**，此时**v'** 与x轴的夹角为(α+β)度。假设**v**的长度为**r**,用极坐标表示点，得$x = rcosα$，$y = r\sin \alpha$，$x' = r\cos \left ( \alpha + \beta \right )$，$y' = r\sin \left ( \alpha + \beta \right )$，那么根据三角函数可得，
$x' = r\left ( \cos \alpha \cos \beta  - \sin \alpha \sin \beta  \right ) = 
\begin{bmatrix}
r\cos \alpha & r\sin \alpha
\end{bmatrix} \begin{bmatrix}
\cos \beta\\
-\sin \beta \\ 
\end{bmatrix}$
$y' = r\left ( \cos \alpha \sin \beta  + \sin \alpha \cos \beta  \right ) = 
\begin{bmatrix}
r\cos \alpha & r\sin \alpha
\end{bmatrix} \begin{bmatrix}
\sin\beta\\
\cos \beta \\ 
\end{bmatrix}$
可以得到旋转矩阵为
$$
M = \begin{bmatrix}
\cos \beta & \sin \beta\\ 
-\sin \beta & \cos \beta \\ 
\end{bmatrix}
$$

下面来看3D空间中绕各轴的旋转的旋转:
绕x轴旋转θ度，Y轴基向量(0, 1, 0)旋转的向量为(0, cosθ, sinθ)，Z轴基向量(0, 0, 1)旋转后的向量为(0, -sinθ, cosθ)
![](http://ww1.sinaimg.cn/large/c5c3a364ly1fvgdcusiqsj20b4090adr.jpg)
得到绕X轴的旋转矩阵为：
$$
M_x(\theta) = \begin{bmatrix}
1 & 0 & 0 \\
0 &\cos \theta & \sin \theta  \\
0 & -\sin \theta & \cos \theta \\
\end{bmatrix}
$$

绕y轴的旋转与绕x轴的旋转类似：
![](http://ww1.sinaimg.cn/large/c5c3a364ly1fvgde12kmhj20b308t42h.jpg)
得到绕Y轴的旋转矩阵为：
$$
M_y(\theta) = \begin{bmatrix}
\cos \theta & 0 & -\sin \theta \\
0 & 1 & 0  \\
\sin \theta & 0 & \cos \theta \\
\end{bmatrix}
$$

同理可得出，绕Z轴的旋转矩阵：
$$
M_z(\theta) = \begin{bmatrix}
\cos \theta & \sin \theta & 0 \\
-\sin \theta &\cos \alpha & 0  \\
0 & 0 & 1 \\
\end{bmatrix}
$$

#### 位移
在2D空间中对点进行位移，用公式可以表示为：
$x' = x + t_x$，$y' = y + t_y$
由于点与矩阵的运算是向量与矩阵的各个分量相乘，无法通过(x, y)与二维矩阵相乘得出常数项$t_x$, $t_y$。
位移的公式可以以下形式：
$x' = 1 * x + 0 * y + 1 * t_x$，
$y' = 0 * x + 1 * y + 1 * t_y$
即向量(x, y, 1)与矩阵$
\begin{bmatrix}
1 & 0\\ 
0 & 1 \\
tx & ty \\
\end{bmatrix}
$的乘积。也就是说，把2D点变为3D向量，2x2矩阵变为3x2矩阵就可以表示2D点的位移。
这实际上就是齐次坐标，简而言之就是用N+1维的坐标来表示N维坐标。以二维坐标举例，笛卡尔坐标为(x, y)，齐次坐标为(x, y, w)。齐次坐标常用的性质有以下几点。
- 齐次坐标与普通坐标的相互转换
当w不为0时，齐次坐标和普通坐标表示的都是点。
齐次坐标(x, y, w)转换为普通坐标为$(\frac{x}{w}, \frac{y}{w})$
普通坐标(x, y)转换为齐次坐标为(xw, yw, w)
当w为0时，齐次坐标和普通坐标表示的都是向量或无穷远处的点。
齐次坐标(x, y, 0)的普通坐标是(x, y)，普通坐标(x, y)的其次坐标是(x, y, 0)。
- 齐次坐标的直线可以相交
$Ax + By + C = 0$, $Ax + By + D = 0$在笛卡尔坐标系里该方程无解。
但是在齐次坐标中，用$\frac{x}{w}$，$\frac{y}{w}$代替x，y，
$A\frac{x}{w} + B\frac{x}{w} + C = 0$，$A\frac{x}{w} + B\frac{x}{w} + D = 0$，即
$Ax + By + Cw = 0$, $Ax + By + Dw = 0$，二者交与(x, y, 0)，这个点在无穷远处。
也就是常见的近大远小的透视效果。
![](http://ww1.sinaimg.cn/large/c5c3a364ly1fvhgnx23ewj2074074dg8.jpg)
#### 位移、旋转、缩放矩阵的结合顺序
根据矩阵的乘法，把多个变换组合到一个矩阵中，这是矩阵变换的最强力之处。由于矩阵乘法不遵守交换律，所有矩阵相乘的顺序很重要。对点(x, y, z)，想要先进行缩放2倍，再位移(2, 0, 0)。很容易知道最终的结果是(2x + 2, 2y, 2z)，写成矩阵相乘的形式为。
$$
\begin{bmatrix}
x & y &z &1
\end{bmatrix}\begin{bmatrix}
2 & 0 & 0 & 0\\ 
0 & 2 & 0 & 0\\ 
0 & 0 & 2 & 0\\ 
0 & 0 & 0 & 1
\end{bmatrix}
\begin{bmatrix}
1 & 0 & 0 & 0\\ 
0 & 1 & 0 & 0\\ 
0 & 0 & 1 & 0\\ 
2 & 0 & 0 & 1
\end{bmatrix} =
\begin{bmatrix}
x & y &z &1
\end{bmatrix}
\begin{bmatrix}
2 & 0 & 0 & 0\\ 
0 & 2 & 0 & 0\\ 
0 & 0 & 2 & 0\\ 
2 & 0 & 0 & 1
\end{bmatrix}
= \begin{bmatrix}
2x + 2 & 2y & 2z & 1 
\end{bmatrix}
$$
如果矩阵的相乘顺序弄错了，先位移后缩放，得到的结果如下。
$$
\begin{bmatrix}
x & y &z &1
\end{bmatrix}
\begin{bmatrix}
1 & 0 & 0 & 0\\ 
0 & 1 & 0 & 0\\ 
0 & 0 & 1 & 0\\ 
2 & 0 & 0 & 1
\end{bmatrix}
\begin{bmatrix}
2 & 0 & 0 & 0\\ 
0 & 2 & 0 & 0\\ 
0 & 0 & 2 & 0\\ 
0 & 0 & 0 & 1
\end{bmatrix} =
\begin{bmatrix}
x & y &z &1
\end{bmatrix}
\begin{bmatrix}
2 & 0 & 0 & 0\\ 
0 & 2 & 0 & 0\\ 
0 & 0 & 2 & 0\\ 
4 & 0 & 0 & 1
\end{bmatrix}
= \begin{bmatrix}
2x + 4 & 2y & 2z & 1 
\end{bmatrix}
$$
在使用的时候一定要弄清楚矩阵变换的先后顺序。通常，我们会先缩放，后旋转，最后位移来保证三者不会相互影响，也最符合直观上的理解。
### 渲染管线中常用矩阵的推导
在渲染管线中常用到的矩阵有相机矩阵、正交矩阵、透视矩阵、视口矩阵等，在这里进行这几个矩阵的推导。
#### 相机矩阵
3D渲染需要用到ZBuffer进行物体遮挡关系的判断。ZBuffer一般采用投影变换后的点归一化后的Z值，所以需要在投影变换前将视线移到原点，视线方向朝向Z轴，这也是相机变换的作用。如图中的相机，假设其位置为$eye$，焦点为$look$，和相机UP方向$up$。我们先将相机移动到原点，然后再旋转摄像机，将其视线方向朝向Z轴即可。最终得到的矩阵也就是位移矩阵与旋转矩阵的乘积。
![](http://ww1.sinaimg.cn/large/c5c3a364ly1fvm49qyx00j20bs09ijrg.jpg)
位移矩阵非常的简单，摄像机的位置为eye，将其移动到原点需要位移-eye，即位移矩阵为：
$$
T_{cam}^{-1} = 
\begin{bmatrix}
1 & 0 & 0 & 0\\ 
0 & 1 & 0 & 0\\ 
0 & 0 & 1 & 0\\ 
-eye.x & -eye.y & -eye.z & 1
\end{bmatrix}
$$
接下来是求旋转矩阵。我们可以先将原坐标系旋转为摄像机朝向的旋转矩阵求出来，其逆矩阵便是将摄像机的朝向旋转到z轴所需要的矩阵。摄像机的朝向$look-eye$实际上就是变换后的z轴基向量，记为$zaxis$，将摄像机的上方向与$zaxis$叉乘可以得到变换后的x轴基向量，记为$xaxis$，再将$zaxis$与$xaxis$乘即得变换后的y轴基向量，记为$yaxis$。
所以由原坐标系旋转为摄像机朝向的矩阵为：
$zaxis = look - eye$
$xaxis = cross(up, zxis)$
$yaxis = cross(zaxis, yaxis)$
$R_{cam} = \begin{bmatrix}
xaxis.x & xaxis.y & xaxis.z & 0\\ 
yaxis.x & yaxis.y & yaxis.z & 0\\ 
zaxis.x & zaxis.y & zaxis.z & 0\\ 
0 & 0 & 0 & 1
\end{bmatrix}$
由于$R_{cam}$是正交矩阵，其逆矩阵为其转置。
$
R_{cam}^{-1} = 
\begin{bmatrix}
xaxis.x & yaxis.x & zaxis.x & 0\\ 
xaxis.y & yaxis.y & zaxis.z & 0\\ 
xaxis.z & yaxis.z & zaxis.z & 0\\ 
0 & 0 & 0 & 1
\end{bmatrix}$
所以可以求得世界坐标到相机坐标的变换矩阵为
$$
M = T_{cam}^{-1}R_{cam}^{-1} = 
\begin{bmatrix}
xaxis.x & yaxis.x & zaxis.x & 0\\ 
xaxis.y & yaxis.y & zaxis.z & 0\\ 
xaxis.z & yaxis.z & zaxis.z & 0\\ 
dot(-eye, xaxis) & dot(-eye, yaxis) & dot(-eye, zaxis) & 1
\end{bmatrix}
$$
#### 投影矩阵
投影变换就是把相机空间的顶点，映射到一个长方体中。长方体中的XY平面内的投影位置即xy坐标决定显示器在哪个位置显示像素，z坐标是深度，用于可见性测试。

![](https://www.codeguru.com/images/article/10123/3dproj01.gif)
##### 正交投影矩阵
正交投影的所有投影线都与XY平面垂直。视锥体包含了所有想显示的几何体的可视空间，是一个轴对齐的盒子，其投影到的几何体叫规范几何体（canonical view volume，以下简称CVV）。如图视锥体的左下角为(l, b, n)，右上角为(r, t, f)。将其投影到CVV中，CVV的左下角坐标为(-1, -1, 0)，右上角为(1, 1, 1)。也就是说在x和轴y轴上的范围均是[-1, 1]，在z轴上为[0, 1]。
![](https://www.codeguru.com/images/article/10123/3dproj02.gif)
CVV变换成视锥体，需要先缩放成与视锥体大小一致的几何体，再位移到视锥体的位置（中心点(0, 0, (f-n)/2)位移至((r+l)/2, (t+b)/2, (f+n)/2))。所以其逆变换就是我们要求的正交投影矩阵。

```math
M_{orth} = 
\begin{bmatrix}
1 & 0 & 0 & 0\\ 
0 & 1 & 0 & 0\\ 
0 & 0 & 1 & 0\\ 
-\frac{r+l}{2} & -\frac{t+b}{2} & -n & 1
\end{bmatrix}
\begin{bmatrix}
\frac{2}{r-l} & 0 & 0 & 0\\ 
0 & \frac{2}{t-b} & 0\\ 
0 & 0 & \frac{1}{f-n} & 0\\ 
0 & 0 & 0 & 1
\end{bmatrix}
=
\begin{bmatrix}
\frac{2}{r-l} & 0 & 0 & 0\\ 
0 & \frac{2}{t-b} & 0 & 0\\ 
0 & 0 & \frac{1}{f-n} & 0\\ 
-\frac{r+l}{r-l} & -\frac{t+b}{t-b} & -\frac{n}{f-n} & 1
\end{bmatrix}
```
下面我们以另外一种方法进行推导，以便的更加容易理解透视投影矩的推导。对CVV的我们知道x'、y'范围均为[-1, 1]，z范围为[0, 1]，对视锥体x[l, r]，y[b, t]，z[n, f]。以x为例进行从视锥体到CVV的推导。
``` math
l <= x <= r
0 <= x - l <= r - l 
0 <= (x - l) / (r-l) <= 1
0 <= (2x - 2l) / (r-l) <=2
-1 <= (2x - r - l) / (r-l) <= 1
由于CVV中-1 <= x' <= 1
x' = (2x - r - l) / (r-l) = 2x / (r-l) -(r+l)/ (r-l)
```
y'的推导上面完全一致，不再赘述。对z'的推导
``` math
n <= z <= f
0 <= z - n <= f - n
0 <= (z - n) / (f - n) <= 1
由于0 <= z' <=1
z' = z / (f-n) - n / (f - n)
```
综上可以得出从视锥体到CVV的变换矩阵与之前推导的是一致的。

##### 透视投影矩阵
透视投影是比正交投影稍微复杂的投影方法，会营造出近大远小的效果。透视投影的视锥体是一个被截断的金字塔——平头截体。
![](http://ww1.sinaimg.cn/large/c5c3a364ly1fvoevjcmllg20dg08ddfp.gif)
如图所示，视锥体的近裁剪面从(l, b, n)延伸至(r, t, n)，远裁剪面的z值为f。
我们以推导那样的方式来推导透视投影矩阵，但是视锥体的x和y的取值范围不是[l, r]和[b, t]，但是z的范围是[n, f]。所以我们需要先把x和y做个变换，使其范围为[l, r]个[b, t]，然后再将其变换到CVV中。
首先将其变换到近裁减面，那么变换后的x'和y'的范围就是我们想要的。利用相似三角形，可以求出x', y'。
![](http://ww1.sinaimg.cn/large/c5c3a364ly1fvogesx4sdj20cv09rq2u.jpg)
``` math
x' = nx / z
y' = ny / z
```
回顾推导正交投影矩阵推导的中间过程，设CVV下的坐标为(x'', y'', z'')，则
``` math
x^{''} = \frac{2x^{'}}{r-l} - \frac{r+l}{r-l} = \frac{2n}{r-l}\frac{x}{z} - \frac{r+l}{r-l}
y^{''} = \frac{2y^{'}}{t-b} - \frac{t+b}{t-b} = \frac{2n}{t-b}\frac{y}{z} - \frac{t+b}{t-b} 
```
我们想要从x推导出x''，所以需要在公式的两边同时乘以z。
``` math
zx^{''} = \frac{2n}{r-l}x - \frac{r+l}{r-l}z
zy^{''} = \frac{2n}{t-b}y - \frac{t+b}{t-b} z
```
很明显这种形式的等式无法写成矩阵的变换。加入我们构造出zz''，就可以写一个变换矩阵把(x, y, z)映射到(zx'', zy'', zz'')，然后各部分再除以z，就可以得到(x'', y'', z'')。
我们知道z''不依赖与x和y，可以由z直接映射。假设zz'' = pz + q，将[n, f]映射到[0, 1]，可得
```
0 = pn + q
f = pf + q
p = f / (f-n)
q = - fn/ (f-n)
zz^{''} = \frac{f}{f-n}z - \frac{fn}{f-n}
```
再加上zw'' = z，w''为1。
可以写出(x, y, z, 1)到(zx'', zy'', zz'', z)的矩阵，同时除以z，也就是(x'', y'', z''， 1)，即为我们所求。
``` math
M_{proj} = \begin{bmatrix}
\frac{2n}{r-l} & 0 & 0 & 0\\ 
0 & \frac{2n}{t-b} & 0 & 0\\ 
-\frac{r+l}{r-l} & -\frac{t+b}{t-b} & \frac{f}{f-n} & 1 \\ 
0 & 0 & -\frac{fn}{f-n} &  0
\end{bmatrix}
```

#### 视口矩阵
经过与投影矩阵相乘后得到的齐次坐标为(zx'', zy'', zz'', z)，除以z归一化，得到(x'', y'', z''， 1)。而点(x'', y'', z'')就是在CVV中的点。(x'', y'', z'')的坐标空间叫NDC(Normalized Device Coordinate)坐标空间，坐标记为$(x_{ndc}, y_{ndc}, z_{ndc})$。视口变换就是将NDC坐标转换为窗口坐标的过程。假设窗口的左上角坐标为(sx, sy)，宽高为(ws, hs)，zmin和zmax指定近远裁剪面到屏幕的映射关系。这些都是线性关系的映射，对x有ndc[-1, 1]到screen[sx, sx + ws]，对y有ndc[1, -1]到screen[sy, sy + hs]，对z有ndc[0, 1]到screen[minz, maxz]。
很容易得到矩阵为：
``` math
M_{viewport}=
\begin{bmatrix}
\frac{w_s}{2} & 0 & 0 & 0\\ 
0 & -\frac{h_s}{2} & 0 & 0\\ 
0 & 0 & \frac{maxz - minz}{2} & 0\\ 
\frac{w_s}{2} + s_x & \frac{h_s}{2}+y_s & \frac{maxz+minz}{2} & 
\end{bmatrix}
```

### CVV的不同
shadowMap

### 参考
- https://www.codeguru.com/cpp/misc/misc/graphics/article.php/c10123/Deriving-Projection-Matrices.htm#page-1