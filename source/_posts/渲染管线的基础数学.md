---
title: 渲染管线的基础数学
categories: 渲染
mathjax: true
---
此篇文章总结一下3D渲染用到的基础数学变换，对渲染管线有一个更清晰的认识。假设读者已经对渲染管线有了一个大致的认知，不会花太多篇幅将渲染关系各个阶段的作用。
### 渲染管线
渲染管线是经过一系列的数学变换，将3D空间中的点，变换到屏幕空间，并进行着色的过程。
包含的流程如下：
![](http://ww1.sinaimg.cn/large/c5c3a364ly1fvgdkh0yf0j20l806rq2v.jpg)
如下图，顶点经过从世界空间变换到投影空间，投影空间下的顶点经过透视除法转换为标准设备空间坐标，再变换到视口下的坐标，将顶点组织成图元，光栅化着色并显示。
![image](https://i.loli.net/2018/09/13/5b9a7ab5a36b9.png)
![IMAGE](https://i.loli.net/2018/09/13/5b9a7ceaa9510.png)

这一系列变换实际上是对点和向量的数学运算，在3D渲染中采用了矩阵用于点和向量的变换。

### 矩阵
#### 矩阵的引入
先介绍一下为什么矩阵可以表示变换。在这边文章中我们以行向量进行矩阵的排布，矩阵的每一行都能解释为变换后的基向量，后面的矩阵全部在左手坐标系，并且基于行向量。

考虑一个向量**V**
$$
V = \begin{bmatrix}
x & y & z 
\end{bmatrix}
= \begin{bmatrix}
x & 0 & 0 
\end{bmatrix}
+
\begin{bmatrix}
0 & y & 0 
\end{bmatrix}
+
\begin{bmatrix}
0 & 0 & z 
\end{bmatrix}
= x\begin{bmatrix}
1 & 0 & 0 
\end{bmatrix}
+
y\begin{bmatrix}
0 & 1 & 0 
\end{bmatrix}
+
z\begin{bmatrix}
0 & 0 & 1 
\end{bmatrix}
$$
也就是向量**V**可以表示为+x, +y, +z轴的单位向量的变换组合。

假设**p**,**q**,**r**分别对应+x,+y,+z轴的单位向量，那么向量**V**就可以表示成**p**,**q**,**r**的线性变换，**p**,**q**,**r**即为基向量。
$$
V = x\mathbf{p} + y\mathbf{q} + z\mathbf{r}
= \begin{bmatrix}
x & y & z 
\end{bmatrix}
\begin{bmatrix}
\mathbf{p} \\ 
\mathbf{q}\\ 
\mathbf{z}
\end{bmatrix}
= \begin{bmatrix}
x & y & z 
\end{bmatrix}
\begin{bmatrix}
p_x & p_y & p_z\\ 
q_x & q_y & q_z\\ 
r_x & r_y & r_z
\end{bmatrix}
$$
那么我们可以定义矩阵**M**，将向量(x, y , z)变换到**V**，即**M**为从(x, y, z)到**V**的变换矩阵。
$$
\boldsymbol{M} = \begin{bmatrix}
p_x & p_y & p_z\\ 
q_x & q_y & q_z\\ 
r_x & r_y & r_z
\end{bmatrix}
$$
如果感觉比较难以理解，这个视频[Transmations](https://www.youtube.com/watch?v=kYB8IZa5AuE&feature=youtu.be&list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab&t=193)或OpenGL的[变换](https://learnopengl-cn.github.io/01%20Getting%20started/07%20Transformations/)可以让你对矩阵表示线性变换有个直观的感受。
#### 旋转和缩放矩阵
考虑一个矩阵2x2的矩阵**M**
$$
M = \begin{bmatrix}
1 & 1\\ 
-1 & 1 \\ 
\end{bmatrix}
$$
从这个矩阵中抽取变换后的基向量**p** = [1 1], **q** = [-1 1]，假设原基向量是(1, 0), (-1, 0)，那么矩阵M表示了对向量缩放$\sqrt{1^2 + 1^2} = \sqrt{1^2 + -1^2} = \sqrt{2}$，然后逆时针旋转$45^{\circ}$。

想要缩放某个向量，只需要将向量的各个分量，分别乘以各个轴的缩放因子。如向量**p**(x, y, z)分别乘以各个轴的缩放$s_x$, $s_y$, $s_z$，得$p\mathbf{'}$，

$$
p' =\begin{bmatrix}
 p_x * s_x & p_y * s_y  &  p_z * s_z
\end{bmatrix}
= p
\begin{bmatrix}
s_x & 0 & 0 \\ 
0 & s_y & 0 \\ 
0 & 0 & s_z
\end{bmatrix}
$$

所以缩放矩阵为:
$$
M = \begin{bmatrix}
s_x & 0 & 0 \\ 
0 & s_y & 0 \\ 
0 & 0 & s_z
\end{bmatrix}
$$

接下来看旋转矩阵，先在2D坐标系里看向量的旋转。在XOY坐标系内任意一点**v**(x, y),其与x轴的夹角为α度，将其旋转β度，得到**v'**，此时**v'** 与x轴的夹角为(α+β)度。假设**v**的长度为**r**,用极坐标表示点，得$x = rcosα$，$y = r\sin \alpha$，$x' = r\cos \left ( \alpha + \beta \right )$，$y' = r\sin \left ( \alpha + \beta \right )$，那么根据三角函数可得，
$x' = r\left ( \cos \alpha \cos \beta  - \sin \alpha \sin \beta  \right ) = 
\begin{bmatrix}
r\cos \alpha & r\sin \alpha
\end{bmatrix} \begin{bmatrix}
\cos \beta\\
-\sin \beta \\ 
\end{bmatrix}$
$y' = r\left ( \cos \alpha \sin \beta  + \sin \alpha \cos \beta  \right ) = 
\begin{bmatrix}
r\cos \alpha & r\sin \alpha
\end{bmatrix} \begin{bmatrix}
\sin\beta\\
\cos \beta \\ 
\end{bmatrix}$
可以得到旋转矩阵为
$$
M = \begin{bmatrix}
\cos \beta & \sin \beta\\ 
-\sin \beta & \cos \beta \\ 
\end{bmatrix}
$$

下面来看3D空间中绕各轴的旋转的旋转:
绕x轴旋转θ度，Y轴基向量(0, 1, 0)旋转的向量为(0, cosθ, sinθ)，Z轴基向量(0, 0, 1)旋转后的向量为(0, -sinθ, cosθ)
![](http://ww1.sinaimg.cn/large/c5c3a364ly1fvgdcusiqsj20b4090adr.jpg)
得到绕X轴的旋转矩阵为：
$$
M_x(\theta) = \begin{bmatrix}
1 & 0 & 0 \\
0 &\cos \theta & \sin \theta  \\
0 & -\sin \theta & \cos \theta \\
\end{bmatrix}
$$

绕y轴的旋转与绕x轴的旋转类似：
![](http://ww1.sinaimg.cn/large/c5c3a364ly1fvgde12kmhj20b308t42h.jpg)
得到绕Y轴的旋转矩阵为：
$$
M_y(\theta) = \begin{bmatrix}
\cos \theta & 0 & -\sin \theta \\
0 & 1 & 0  \\
\sin \theta & 0 & \cos \theta \\
\end{bmatrix}
$$

同理可得出，绕Z轴的旋转矩阵：
$$
M_z(\theta) = \begin{bmatrix}
\cos \theta & \sin \theta & 0 \\
-\sin \theta &\cos \alpha & 0  \\
0 & 0 & 1 \\
\end{bmatrix}
$$

#### 位移
在2D空间中对点进行位移，用公式可以表示为：
$x' = x + t_x$，$y' = y + t_y$
由于点与矩阵的运算是向量与矩阵的各个分量相乘，无法通过(x, y)与二维矩阵相乘得出常数项$t_x$, $t_y$。
位移的公式可以以下形式：
$x' = 1 * x + 0 * y + 1 * t_x$，
$y' = 0 * x + 1 * y + 1 * t_y$
即向量(x, y, 1)与矩阵$
\begin{bmatrix}
1 & 0\\ 
0 & 1 \\
tx & ty \\
\end{bmatrix}
$的乘积。也就是说，把2D点变为3D向量，2x2矩阵变为3x2矩阵就可以表示2D点的位移。
这实际上就是齐次坐标，简而言之就是用N+1维的坐标来表示N维坐标。以二维坐标举例，笛卡尔坐标为(x, y)，齐次坐标为(x, y, w)。齐次坐标常用的性质有以下几点。
- 齐次坐标与普通坐标的相互转换
当w不为0时，齐次坐标和普通坐标表示的都是点。
齐次坐标(x, y, w)转换为普通坐标为$(\frac{x}{w}, \frac{y}{w})$
普通坐标(x, y)转换为齐次坐标为(xw, yw, w)
当w为0时，齐次坐标和普通坐标表示的都是向量或无穷远处的点。
齐次坐标(x, y, 0)的普通坐标是(x, y)，普通坐标(x, y)的其次坐标是(x, y, 0)。
- 齐次坐标的直线可以相交
$Ax + By + C = 0$, $Ax + By + D = 0$在笛卡尔坐标系里该方程无解。
但是在齐次坐标中，用$\frac{x}{w}$，$\frac{y}{w}$代替x，y，
$A\frac{x}{w} + B\frac{x}{w} + C = 0$，$A\frac{x}{w} + B\frac{x}{w} + D = 0$，即
$Ax + By + Cw = 0$, $Ax + By + Dw = 0$，二者交与(x, y, 0)，这个点在无穷远处。
也就是常见的近大远小的透视效果。
![](http://ww1.sinaimg.cn/large/c5c3a364ly1fvhgnx23ewj2074074dg8.jpg)
#### 位移、旋转、缩放矩阵的结合顺序
根据矩阵的乘法，把多个变换组合到一个矩阵中，这是矩阵变换的最强力之处。由于矩阵乘法不遵守交换律，所有矩阵相乘的顺序很重要。对点(x, y, z)，想要先进行缩放2倍，再位移(2, 0, 0)。很容易知道最终的结果是(2x + 2, 2y, 2z)，写成矩阵相乘的形式为。
$$
\begin{bmatrix}
x & y &z &1
\end{bmatrix}\begin{bmatrix}
2 & 0 & 0 & 0\\ 
0 & 2 & 0 & 0\\ 
0 & 0 & 2 & 0\\ 
0 & 0 & 0 & 1
\end{bmatrix}
\begin{bmatrix}
1 & 0 & 0 & 0\\ 
0 & 1 & 0 & 0\\ 
0 & 0 & 1 & 0\\ 
2 & 0 & 0 & 1
\end{bmatrix} =
\begin{bmatrix}
x & y &z &1
\end{bmatrix}
\begin{bmatrix}
2 & 0 & 0 & 0\\ 
0 & 2 & 0 & 0\\ 
0 & 0 & 2 & 0\\ 
2 & 0 & 0 & 1
\end{bmatrix}
= \begin{bmatrix}
2x + 2 & 2y & 2z & 1 
\end{bmatrix}
$$
如果矩阵的相乘顺序弄错了，先位移后缩放，得到的结果如下。
$$
\begin{bmatrix}
x & y &z &1
\end{bmatrix}
\begin{bmatrix}
1 & 0 & 0 & 0\\ 
0 & 1 & 0 & 0\\ 
0 & 0 & 1 & 0\\ 
2 & 0 & 0 & 1
\end{bmatrix}
\begin{bmatrix}
2 & 0 & 0 & 0\\ 
0 & 2 & 0 & 0\\ 
0 & 0 & 2 & 0\\ 
0 & 0 & 0 & 1
\end{bmatrix} =
\begin{bmatrix}
x & y &z &1
\end{bmatrix}
\begin{bmatrix}
2 & 0 & 0 & 0\\ 
0 & 2 & 0 & 0\\ 
0 & 0 & 2 & 0\\ 
4 & 0 & 0 & 1
\end{bmatrix}
= \begin{bmatrix}
2x + 4 & 2y & 2z & 1 
\end{bmatrix}
$$
在使用的时候一定要弄清楚矩阵变换的先后顺序。通常，我们会先缩放，后旋转，最后位移来保证三者不会相互影响，也最符合直观上的理解。
### 渲染管线中常用矩阵的推导
下图是渲染管线中的各个变换以及变换后的点的术语叫法。原始顶点叫物体坐标，经过相机变换后叫相机坐标，投影后为裁剪坐标，透视除法除以w之后叫标准设备坐标（NDC），再经过视口变换后变为窗口坐标。常用到的变换矩阵有相机矩阵、正交矩阵、透视矩阵、视口矩阵等，在这里进行这几个矩阵的推导。
![](http://ww1.sinaimg.cn/large/c5c3a364ly1fvp22z590uj215o04gjry.jpg)

#### 相机矩阵
3D渲染需要用到ZBuffer进行物体遮挡关系的判断。ZBuffer一般采用投影变换后的点归一化后的Z值，所以需要在投影变换前将视线移到原点，视线方向朝向Z轴，这也是相机变换的作用。如图中的相机，假设其位置为$eye$，焦点为$look$，和相机UP方向$up$。我们先将相机移动到原点，然后再旋转摄像机，将其视线方向朝向Z轴即可。最终得到的矩阵也就是位移矩阵与旋转矩阵的乘积。
![](http://ww1.sinaimg.cn/large/c5c3a364ly1fvm49qyx00j20bs09ijrg.jpg)
位移矩阵非常的简单，摄像机的位置为eye，将其移动到原点需要位移-eye，即位移矩阵为：
$$
T_{cam}^{-1} = 
\begin{bmatrix}
1 & 0 & 0 & 0\\ 
0 & 1 & 0 & 0\\ 
0 & 0 & 1 & 0\\ 
-eye.x & -eye.y & -eye.z & 1
\end{bmatrix}
$$
接下来是求旋转矩阵。我们可以先将原坐标系旋转为摄像机朝向的旋转矩阵求出来，其逆矩阵便是将摄像机的朝向旋转到z轴所需要的矩阵。摄像机的朝向$look-eye$实际上就是变换后的z轴基向量，记为$zaxis$，将摄像机的上方向与$zaxis$叉乘可以得到变换后的x轴基向量，记为$xaxis$，再将$zaxis$与$xaxis$乘即得变换后的y轴基向量，记为$yaxis$。
所以由原坐标系旋转为摄像机朝向的矩阵为：
$zaxis = look - eye$
$xaxis = cross(up, zxis)$
$yaxis = cross(zaxis, yaxis)$
$R_{cam} = \begin{bmatrix}
xaxis.x & xaxis.y & xaxis.z & 0\\ 
yaxis.x & yaxis.y & yaxis.z & 0\\ 
zaxis.x & zaxis.y & zaxis.z & 0\\ 
0 & 0 & 0 & 1
\end{bmatrix}$
由于$R_{cam}$是正交矩阵，其逆矩阵为其转置。
$
R_{cam}^{-1} = 
\begin{bmatrix}
xaxis.x & yaxis.x & zaxis.x & 0\\ 
xaxis.y & yaxis.y & zaxis.z & 0\\ 
xaxis.z & yaxis.z & zaxis.z & 0\\ 
0 & 0 & 0 & 1
\end{bmatrix}$
所以可以求得世界坐标到相机坐标的变换矩阵为
$$
M = T_{cam}^{-1}R_{cam}^{-1} = 
\begin{bmatrix}
xaxis.x & yaxis.x & zaxis.x & 0\\ 
xaxis.y & yaxis.y & zaxis.z & 0\\ 
xaxis.z & yaxis.z & zaxis.z & 0\\ 
dot(-eye, xaxis) & dot(-eye, yaxis) & dot(-eye, zaxis) & 1
\end{bmatrix}
$$
#### 投影矩阵
投影变换就是把相机空间的点，映射到一个长方体中。长方体中的XY平面内的投影位置即xy坐标决定显示器在哪个位置显示像素，z坐标是深度，用于可见性测试。相机空间中的可见点，组成视锥体。其投影到的长方体叫规范几何体（canonical view volume），以下简称CVV。

![](https://www.codeguru.com/images/article/10123/3dproj01.gif)
##### 正交投影矩阵
正交投影的所有投影线都与XY平面垂直。视锥体包含了所有，是一个轴对齐的盒子，其投影到的几何体叫规范几何体（canonical view volume，以下简称CVV）。如图视锥体的左下角为(l, b, n)，右上角为(r, t, f)。将其投影到CVV中，CVV的左下角坐标为(-1, -1, 0)，右上角为(1, 1, 1)。也就是说在x和轴y轴上的范围均是[-1, 1]，在z轴上为[0, 1]。CVV点的取值范围也是NDC的范围。
![](https://www.codeguru.com/images/article/10123/3dproj02.gif)


CVV变换成视锥体，需要先缩放成与视锥体大小一致的几何体，再位移到视锥体的位置（中心点$(0, 0, \frac{f-n}{2})$）位移至$(\frac{r+l}{2}, \frac{t+b}{2}, \frac{f+n}{2})$。所以其逆变换就是我们要求的正交投影矩阵。
$$
M_{orth} = 
\begin{bmatrix}
1 & 0 & 0 & 0\\ 
0 & 1 & 0 & 0\\ 
0 & 0 & 1 & 0\\ 
-\frac{r+l}{2} & -\frac{t+b}{2} & -n & 1
\end{bmatrix}
\begin{bmatrix}
\frac{2}{r-l} & 0 & 0 & 0\\ 
0 & \frac{2}{t-b} & 0\\ 
0 & 0 & \frac{1}{f-n} & 0\\ 
0 & 0 & 0 & 1
\end{bmatrix}=
\begin{bmatrix}
\frac{2}{r-l} & 0 & 0 & 0\\ 
0 & \frac{2}{t-b} & 0 & 0\\ 
0 & 0 & \frac{1}{f-n} & 0\\ 
-\frac{r+l}{r-l} & -\frac{t+b}{t-b} & -\frac{n}{f-n} & 1
\end{bmatrix}
$$
下面我们以另外一种方法进行推导，以便更加容易理解透视投影矩的推导。视锥体中的点记为(x, y, z)，有$l \leq x \leq r$，$b \leq y \leq t$，$n \leq z \leq f$。NDC坐标记为(x', y', z')，有$-1 \leq x' \leq 1$，$-1 \leq y' \leq 1$， $0 \leq z' \leq 1$。以x为例进行从视锥体到CVV的推导。
$l \leq x \leq r$

$0 \leq x - l \leq r - l $

$0 \leq \frac{x - l}{r-l} \leq 1$

$0 \leq \frac{2x - 2l}{r-l} \leq2$

$-1 \leq \frac{2x - r - l}{r-l} \leq 1$

由于$-1 \leq x' \leq 1$，所以

$x' = \frac{2x - r - l}{r-l} = \frac{2x}{r-l} -\frac{r+l}{r-l}$

y'的推导上面完全一致，不再赘述。对z'的推导
$n \leq z \leq f$

$0 \leq z - n \leq f - n$

$0 \leq \frac{z-n}{f-n} \leq 1$

由于$0 \leq z' \leq 1$，所以
$z' = \frac{z}{f-n} - \frac{n}{f-n}$

综上可以得出从视锥体到CVV的变换矩阵与之前推导的是一致的。

##### 透视投影矩阵
透视投影是比正交投影稍微复杂的投影方法，会呈现出近大远小的效果。透视投影的视锥体是一个被截断的金字塔——平头截体。
![](http://ww1.sinaimg.cn/large/c5c3a364ly1fvoevjcmllg20dg08ddfp.gif)
如图所示，视锥体的近裁剪面从(l, b, n)延伸至(r, t, n)，远裁剪面的z值为f。
我们以推导正交投影矩阵的思路来推导透视投影矩阵，虽然z的范围是[n, f]，但是视锥体的x和y的取值范围不是[l, r]和[b, t]。所以我们需要先把x和y做个变换，使其范围为[l, r]和[b, t]，然后按照正交投影的方法变换到CVV中。
对视锥体中的一个点$(x, y, z)$，首先将其变换到近裁减面，得到$(x', y', n)$。利用相似三角形，可以求出$x', y'$。
$x' = \frac{nx}{z}$

$y' = \frac{ny}{z}$

![](http://ww1.sinaimg.cn/large/c5c3a364ly1fvogesx4sdj20cv09rq2u.jpg)


设最终变换到NDC坐标$(x'', y'', z'')$，回顾正交投影的中间推导过程，并将$x'和y'$代入得
$x'' = \frac{2x^{'}}{r-l} - \frac{r+l}{r-l} = \frac{2n}{r-l}\frac{x}{z} - \frac{r+l}{r-l}$

$y'' = \frac{2y^{'}}{t-b} - \frac{t+b}{t-b} = \frac{2n}{t-b}\frac{y}{z} - \frac{t+b}{t-b} $
我们想要从$(x, y, z)$推导出$(x'', y'', z'')$，对上面的公式两边同时乘以z。
$zx'' = \frac{2n}{r-l}x - \frac{r+l}{r-l}z$

$zy'' = \frac{2n}{t-b}y - \frac{t+b}{t-b}z$

很明显这种形式的等式无法写成矩阵的变换。如果我们构造出$zz''$，就可以写一个变换矩阵把$(x, y, z)$映射到$(zx'', zy'', zz'')$，然后各部分再除以z，就可以得到$(x'', y'', z'')$。
$z''$不依赖与$x$和$y$，可以由$z$直接映射。假设$zz'' = pz + q$，有$n \leq z \leq f$，$0 \leq z'' \leq 1$，即当$z=n$时，$z''=0$，$z=f$时，$z'' = 1$，
$0 = pn + q$

$f = pf + q$
求出$p，q$
$p = \frac{f}{f-n}$

$q = -\frac{fn}{f-n}$
于是，
$zz^{''} = \frac{f}{f-n}z - \frac{fn}{f-n}$

再加上齐次坐标的w分部$w'' = 1$，乘以$z$，有$zw'' = z$。
综上，可以写出从$(x, y, z, 1)$到$(zx'', zy'', zz'', z)$的变换矩阵，同时除以$z$，即为CVV下的坐标$(x'', y'', z'',1)$。
$$
M_{proj} = \begin{bmatrix}
\frac{2n}{r-l} & 0 & 0 & 0\\ 
0 & \frac{2n}{t-b} & 0 & 0\\ 
-\frac{r+l}{r-l} & -\frac{t+b}{t-b} & \frac{f}{f-n} & 1 \\ 
0 & 0 & -\frac{fn}{f-n} &  0
\end{bmatrix}
$$

#### 视口矩阵
经过与投影矩阵相乘后得到的齐次坐标为(zx'', zy'', zz'', z)，除以z归一化，得到(x'', y'', z''，1)，即NDC坐标，在三维空间的点记为$(x_{ndc}, y_{ndc}, z_{ndc})$。

视口变换就是将NDC坐标转换为窗口坐标的过程。在视口变换中，硬件也对$z_{ndc}$做了映射，并保存到深度缓冲中。假设窗口下的坐标为$(x_s, y_s, z_s)$，左上角坐标为$(s_x, s_y)$，宽高为$(w_s, h_s)$，$zmin$和$zmax$指定近远裁剪面到屏幕的映射关系。将NDC坐标映射到这个窗口坐标，这些都是线性关系的映射。在DirectX中窗口的原点为左上角，所以对y轴的映射要做个翻转。
$x_{ndc}：[-1, 1]\rightarrow [s_x, s_x + w_s]$

$y_{ndc}:[1, -1]\rightarrow [s_y, s_y + h_s]$

$z_{ndc}:[0, 1]\rightarrow [minz, maxz]$
很容易得到矩阵为：
$$
M_{viewport}=
\begin{bmatrix}
\frac{w_s}{2} & 0 & 0 & 0\\ 
0 & -\frac{h_s}{2} & 0 & 0\\ 
0 & 0 & maxz - minz & 0\\ 
\frac{w_s}{2} + s_x & \frac{h_s}{2}+s_y & minz & 
\end{bmatrix}
$$

#### CVV的差异
投影矩阵和视口矩阵是根据CVV相关的。在软件层，可以假设CVV是大小为(2, 2, 1)的立方体。但是在硬件进行视口变换的时候，这个CVV是根硬件相关的。在OpenGL中是长宽高为2的立方体，又由于OpenGL的原点在左下角，不需要对y进行翻转。所以OpenlGL的视口矩阵如下：
$$
M_{viewport}=
\begin{bmatrix}
\frac{w_s}{2} & 0 & 0 & 0\\ 
0 & \frac{h_s}{2} & 0 & 0\\ 
0 & 0 & \frac{maxz - minz}{2} & 0\\ 
\frac{w_s}{2} + s_x & \frac{h_s}{2}+s_y & \frac{maxz+minz}{2} & 
\end{bmatrix}
$$
这一点是根据深度图推导某个点在世界中的位置的一个重要的前提条件。
### 总结
在这里只推导介绍了最基本的变换，但是理解掌握这些，就会对3D的流水线有一个较为清晰的认识。在做复杂效果的时候，灵巧运用数学变换，会使问题变得清晰明朗。以ShadowMap的实现中对变换的要求为例：
- 已知光照的相机矩阵$lightview$和光照的投影矩阵$lightproj$，利用变换到NDC变换（变换到长方体中）的逆变换，可以求出光锥体的八个顶点在世界位置中。
- 已知场景的深度图和ShadowMap，比较场景中的某一个点是否在阴影中。需要把场景中的点变换到光照空间。从场景深度图中读取深度，和在窗口上的坐标组成窗口坐标。经过逆视口变换到NDC坐标，再经过逆相机投影变换到世界坐标，然后光照的相机投影变换到NDC坐标，再经过视口变换得到与ShadowMap在同一空间下的深度，与ShadowMap里的深度进行比较即可知是否在阴影中。
### 参考
- https://www.codeguru.com/cpp/misc/misc/graphics/article.php/c10123/Deriving-Projection-Matrices.htm#page-1