---
title: ARGB8颜色的存储
categories: 渲染
---
在OpenGL上GL_RGBA是常用的内置像素格式，GL_BGRA在OpenlGL上是以扩展的形式给出的。我们会比较普遍接受RGBA的颜色格式。而当我们输入的颜色为A8R8G8B8的32位颜色，并且设置颜色格式为RGBA时，会发现得到的颜色R和B与我们期望的是相反的。如输入的红色0xFFFF0000，得到的是蓝色0xFF0000FF。在这里，我们以32位数据的存储和硬件API的角度来理解和解决这个问题。
### 一、小端存储和大端存储
在计算机中，数据以字节为单位存储。对32位的int型，具有四个字节，就出现了如何存储这四个字节的问题。常用的存储模式有两种：大端模式（big-endian）和小端模式（little-endian）。
> 大端模式：数据的高字节保存在内存的低地址中，低字节保存在内存的高地址中。类似于字符串的存储顺序，如"hello"，内存中存储的顺序从'h'到'\0'。

> 小端模式：数据的高字节保存在内存的高地址中，数据的低字节保存在低地址中。更加符合我们的理解习惯。

下面以32位的数值0x12345678为例，展示小端存储和大端存储的区别。
![](http://ww1.sinaimg.cn/large/c5c3a364ly1fx5lm1jb3aj20cf06u3ye.jpg)
我们常用的x86是小端模式，大多数arm也是小端模式，Power PC是大端模式。
小端模式有一个好处是强制类型转换，不需要调整字节的内容。
``` c++
int num = 0x12345678;
char* cptr = (char*) &num; // cptr指向的数据为0x78.
int result = *(int*) cptr; // 将cptr指针转换为int，取数据，得到0x12345678。
```
### 二、顶点和贴图中的ARGB8颜色
假设我们已经规定好32位颜色的写入格式为ARGB8，而移动硬件都是小端存储，按照字节从低地址到高地址的顺序，也就是B8G8R8A8的存储格式。
对像素格式而言，DX11和Metal都支持B8G8R8A8的格式，OpenGL也支持GL_BGRA的格式，虽然在OpenGLES2.0上，这种格式是通过扩展给出的，但是目前市场上的安卓机应当是基本全支持的（做过测试，安卓2.2系统的古董机器也支持这种扩展）。
对顶点色来说，DX11支持声明顶点格式为B8G8R8A8格式。而Metal和OpenGL就没有这种顶点格式了。虽然Metal有**uchar4Normalized_bgra**来做R和B的交换，但是好像有版本的要求。
对于OpenGLES，3.0以上支持下面的交换方法：
``` c++
glTexParameteri(Target, GL_TEXTURE_SWIZZLE_R, GL_BLUE);
glTexParameteri(Target, GL_TEXTURE_SWIZZLE_B, GL_RED);
```
对ES2.0就需要在顶点Shader里做R与B的交换操作了。

总之，秉着输入端的存储格式与输出端的读取格式保持一致，就可以保证输入与输出的结果是一致的。

### 三、总结
起初发现在应用层居然对不同平台的颜色做了不同的处理，DX的格式为ARGB8，而Metal的为ABGR8。很明显，这是很不好的设计。在此记录下原因和修改方法。